##########################################################
# TypoScript Config for Pagebrowser:Reloaded			 #
##########################################################

# include rendering class
includeLibs.tx_cagpagebrowser = EXT:cag_pagebrowser/pi1/class.tx_cagpagebrowser.php

plugin.tx_cagpagebrowser = COA
plugin.tx_cagpagebrowser {

	# registers
	5 = LOAD_REGISTER
	5 {
	
		excludeUids.cObject = TEXT
		excludeUids.cObject {
			value = {$plugin.tx_cagpagebrowser.excludeUidList}
			required = 1
			wrap = AND uid NOT IN (|)
		}	
	
		index.cObject = TEXT
		index.cObject {
			data = page:pid
		}
		
		subsection.cObject = CONTENT
		subsection.cObject {
			table = pages		
			# select the lowest valid page among the subpages of the current page
			select {
				pidInList.data = page:uid
				orderBy = sorting
				where = doktype NOT IN ({$plugin.tx_cagpagebrowser.dtypes})
				andWhere.dataWrap = deleted=0 AND hidden=0 AND nav_hide=0 {register : excludeUids}
				max = 1
			}
			
			renderObj = TEXT
			renderObj.data = field:uid
			
			# insert SUBSECTION only in recursive mode and if there are subpages
			stdWrap {		
				if {
					isTrue.numRows {
						table = pages
						# this selects the lowest valid page among the subpages of the SECTION
						select {
							pidInList.data = page:uid
							orderBy = sorting
							where = doktype NOT IN ({$plugin.tx_cagpagebrowser.dtypes})
							andWhere = deleted=0 AND hidden=0 AND nav_hide=0
							max = 1
						}
					}
					value = rec
					equals = {$plugin.tx_cagpagebrowser.browserMode}
				}
			}		
		}
	
		first.cObject = CONTENT
		first.cObject {
			table = pages
			select {
				selectFields = uid
				pidInList.data = page:pid
				orderBy = sorting
				where = doktype NOT IN ({$plugin.tx_cagpagebrowser.dtypes})
				andWhere.dataWrap = deleted=0 AND hidden=0 AND nav_hide=0 {register : excludeUids}
				max = 1
			}
			renderObj = TEXT
			renderObj.field = uid
		}
		
		last.cObject = CONTENT
		last.cObject {
			table = pages
			select {
				selectFields = uid			
				pidInList.data = page:pid
				orderBy = sorting
				where = doktype NOT IN ({$plugin.tx_cagpagebrowser.dtypes})
				andWhere.dataWrap = deleted=0 AND hidden=0 AND nav_hide=0 {register : excludeUids}
				begin = total-1
				max = 1		
			}
			renderObj = TEXT
			renderObj.field = uid			
		}		
		
		previous.cObject = CONTENT
		previous.cObject {
			table = pages
			select {
				selectFields = uid			
				pidInList.data = page:pid
				orderBy = sorting
				where = doktype NOT IN ({$plugin.tx_cagpagebrowser.dtypes})
				andWhere.dataWrap = sorting < {page:sorting} AND deleted=0 AND hidden=0 AND nav_hide=0 {register : excludeUids}
				begin = total-1
				max = 1
			}
			renderObj = TEXT
			renderObj.field = uid
			
			stdWrap.override {
				if {
					isTrue = {$plugin.tx_cagpagebrowser.browserLoop}
					value.data = register:first
					equals.data = TSFE:id
				}
				cObject < plugin.tx_cagpagebrowser.5.last.cObject
			}
		}
		
		next.cObject = CONTENT
		next.cObject {
			table = pages
			select {
				selectFields = uid			
				pidInList.data = page:pid
				orderBy = sorting
				where = doktype NOT IN ({$plugin.tx_cagpagebrowser.dtypes})
				andWhere.dataWrap = sorting > {page:sorting} AND deleted=0 AND hidden=0 AND nav_hide=0 {register : excludeUids}
				max = 1			
			}
			renderObj = TEXT
			renderObj.field = uid
			
			stdWrap.override {
				if {
					isTrue = {$plugin.tx_cagpagebrowser.browserLoop}
					value.data = register:last
					equals.data = TSFE:id
				}
				cObject < plugin.tx_cagpagebrowser.5.first.cObject
			}			
		}
		
		indexTitle {
			cObject = TEXT
			cObject.dataWrap = DB:pages:{register:index}:title
			wrap = {|}
			insertData = 1
		}
		
		subsectionTitle < .indexTitle
		subsectionTitle.cObject.dataWrap = DB:pages:{register:subsection}:title
		
		firstTitle < .indexTitle
		firstTitle.cObject.dataWrap = DB:pages:{register:first}:title
		
		previousTitle < .indexTitle
		previousTitle.cObject.dataWrap = DB:pages:{register:previous}:title
		
		nextTitle < .indexTitle
		nextTitle.cObject.dataWrap = DB:pages:{register:next}:title
		
		lastTitle < .indexTitle
		lastTitle.cObject.dataWrap = DB:pages:{register:last}:title
		
	}
	
	# index
	10 = TEXT
	10.wrap = {$plugin.tx_cagpagebrowser.wrapIndex}
	10 {
		# get page title
		data = register:indexTitle

		# build link to the INDEX page
		typolink.parameter.data = register:index
		typolink.ATagParams.dataWrap = title="{register:indexTitle}"

		# pagetitle overridden with browseword if true
		override.cObject = TEXT
		override.cObject.value = {$plugin.tx_cagpagebrowser.indexword}
		override.cObject.wrap = <span class="index"> | </span>
		override.if {
			value = 1
			equals = {$plugin.tx_cagpagebrowser.browsewords}
		}
	}
	
	# subsection
	20 = TEXT
	20.wrap = {$plugin.tx_cagpagebrowser.wrapSubsection}
	20 {
		# get page title
		data = register:subsectionTitle

		# build link to the INDEX page
		typolink.parameter.data = register:subsection
		typolink.ATagParams.dataWrap = title="{register:subsectionTitle}"

		# pagetitle overridden with browseword if true
		override.cObject = TEXT
		override.cObject.value = {$plugin.tx_cagpagebrowser.subsection}
		override.cObject.wrap = <span class="subsection"> | </span>
		override.if {
			value = 1
			equals = {$plugin.tx_cagpagebrowser.browsewords}
		}
		
		if.isTrue.data = register:subsection
	}	

	# first
	30 = TEXT
	30.wrap = {$plugin.tx_cagpagebrowser.wrapFirst}
	30 {
		# get FIRST page title
		data = register:firstTitle

		# build link to first page - if not in browserLoop mode, link to first page will only be generated if not on first page
		typolink.parameter.cObject = TEXT
		typolink.parameter.cObject {
			data = register:first
			if {
				value.data = register:first
				equals.data = TSFE:id
				isFalse = {$plugin.tx_cagpagebrowser.browserLoop}
				negate = 1
			}
		}
		typolink.ATagParams.dataWrap = title="{register:firstTitle}"

		# pagetitle overridden with browseword if is true
		override.cObject = TEXT
		override.cObject.value = {$plugin.tx_cagpagebrowser.first}
		override.cObject.wrap = <span class="previous first"> | </span>
		override.if {
			value = 1
			equals = {$plugin.tx_cagpagebrowser.browsewords}
		}
	}
	
	# previous
	40 = TEXT
	40.wrap = {$plugin.tx_cagpagebrowser.wrapPrevious}
	40 {
		# get PREVIOUS page title
		data = register:previousTitle

		# build link to the PREVIOUS page
		typolink.parameter.cObject = TEXT
		typolink.parameter.cObject {
			data = register:previous
			if {
				value.data = register:previous
				equals.data = TSFE:id
				negate = 1
			}
		}
		typolink.ATagParams.dataWrap = title="{register:previousTitle}"

		# pagetitle overridden with browseword if is true
		override.cObject = TEXT
		override.cObject.value = {$plugin.tx_cagpagebrowser.previous}
		override.cObject.wrap = <span class="previous"> | </span>
		override.if {
			value = 1
			equals = {$plugin.tx_cagpagebrowser.browsewords}
		}
	}
	
	# pagenumbers
	50 = HMENU
	50 {
	
		stdWrap.if.isTrue = {$plugin.tx_cagpagebrowser.pageNumbers}

		special = directory
		special.value.data = page:pid

		excludeUidList = {$plugin.tx_cagpagebrowser.excludeUidList}
		excludeDoktypes = {$plugin.tx_cagpagebrowser.dtypes}

		1 = TMENU
		1 {

			noBlur = 1

			itemArrayProcFunc = tx_cagpagebrowser->pageNumbers
			stepSize = {$plugin.tx_cagpagebrowser.pagenumbers.stepSize}
			useNumbering = {$plugin.tx_cagpagebrowser.pagenumbers.useNumbering}

			wrap = {$plugin.tx_cagpagebrowser.pagenumbers.wrapPageNumbers}

			NO.allWrap = {$plugin.tx_cagpagebrowser.pagenumbers.wrapSingleNumber}

			CUR < .NO
			CUR = 1
			CUR.doNotLinkIt = 1
		}
		
	}		

	# next
	60 = TEXT
	60.wrap = {$plugin.tx_cagpagebrowser.wrapNext}
	60 {
		# get PREVIOUS page title
		data = register:nextTitle

		# build link to the NEXT page
		typolink.parameter.cObject = TEXT
		typolink.parameter.cObject {
			data = register:next
			if {
				value.data = register:next
				equals.data = TSFE:id
				negate = 1
			}
		}
		typolink.ATagParams.dataWrap = title="{register:nextTitle}"

		# pagetitle overridden with browseword if is true
		override.cObject = TEXT
		override.cObject.value = {$plugin.tx_cagpagebrowser.next}
		override.cObject.wrap = <span class="next"> | </span>
		override.if {
			value = 1
			equals = {$plugin.tx_cagpagebrowser.browsewords}
		}
	}

	# last
	70 = TEXT
	70.wrap = {$plugin.tx_cagpagebrowser.wrapLast}
	70 {
		# get LAST page title
		data = register:lastTitle

		# if not in browserLoop mode links to last/next page will NOT be generated on last page of tree branch		
		typolink.parameter.cObject = TEXT
		typolink.parameter.cObject {
			data = register:last
			if {
				value.data = register:last 
				equals.data = TSFE:id
				isFalse = {$plugin.tx_cagpagebrowser.browserLoop}
				negate = 1
			}
		}		
		typolink.ATagParams.dataWrap = title="{register:lastTitle}"

		# pagetitle overridden with browseword if is true
		override.cObject = TEXT
		override.cObject.value = {$plugin.tx_cagpagebrowser.last}
		override.cObject.wrap = <span class="next last"> | </span>
		override.if {
			value = 1
			equals = {$plugin.tx_cagpagebrowser.browsewords}
		}
	}
	
	userFunc >

	stdWrap {
		if.value = 1
		if.equals.cObject = USER
		if.equals.cObject {
			userFunc = tx_cagpagebrowser->main
			browserMode = {$plugin.tx_cagpagebrowser.browserMode}
			excludeUidList = {$plugin.tx_cagpagebrowser.excludeUidList}
		}
	}

}